[{"title":"CF2032E","path":"/2024/11/02/CF2032E/","content":"题意给一个长度为 （且 为奇数） 首尾相连的数组 ，每次操作你可以将 分别加上 注意 时， 指的是 ，同理， 时， 指的是 。 请你找出一个操作序列，即每个位置上需要操作几次，将 中所有元素变成相同值。 题解设第 个位置上需要操作 次，最后得到的值为 ，则有： \\begin{pmatrix} 2&1&0&\\cdots&0&1\\\\ 1&2&1&\\cdots&0&0\\\\ \\vdots& & & & &\\vdots\\\\ 1&0&\\cdots&0&1&2 \\end{pmatrix} \\begin{pmatrix} x_1\\\\x_2\\\\\\vdots\\\\x_n \\end{pmatrix} = \\begin{pmatrix} V-a_1\\\\V-a_2\\\\\\vdots\\\\V-a_n \\end{pmatrix}作差分可得 \\begin{pmatrix} 1&-1&-1&0&0&\\cdots&0&1\\\\ 1&1&-1&-1&0&\\cdots&0&0\\\\ 0&1&1&-1&-1&\\cdots&0&0\\\\ \\vdots& & & & & & &\\vdots\\\\ -1&-1&0&0&0&\\cdots&1&1 \\end{pmatrix} \\begin{pmatrix} x_1\\\\x_2\\\\\\vdots\\\\x_n \\end{pmatrix} =- \\begin{pmatrix} a_1-a_2\\\\a_2-a_3\\\\\\vdots\\\\a_n-a_1 \\end{pmatrix}即 ，由于 已知，记为 ，再将正负两两组合，即 ，再令 ，则 。 显然有 2\\sum_{i=1}^n y_i=\\sum_{i=1}^nb_i\\tag{1} 然后取 中偶数项可以发现，结合 也是偶数的条件，有 y_1+y_2+\\cdots+y_{n-1}=b_2+b_4+\\cdots+b_{n-1}发现还差一项 ，加上 ，得到 y_1+\\sum_{i=1}^ny_i=\\sum_{i为偶数}^nb_i+b_1 \\tag{2}于是结合 可以解得 ，再依次代入 中求得所有 。 然后任取 的值，通过 求的 为奇数时的 ，然后通过 转移到 为偶数的情况，因而求得所有 的值，最后如果有小于 的值则全部加上一个偏置即可。 时间复杂度："},{"path":"/2024/10/27/2024icpc成都I/","content":"题意给定一个长度为 $n(1\\le n\\le 2\\times 10^5)$ 的序列 ${a}$ ，问有多少个好的划分。 一个大小为 $k$ 的好的划分定义为将 ${a}$ 划分为 $\\lceil\\frac{n}{k}\\rceil$ 个部分（最后一部分可能少于 $k$ 个数），每个部分内部都单调不降。 现在有 $q$ 次修改，每次修改将 $a_p$ 修改为 $v$ ，计算修改前和每次修改后好的分区的数量。 题解"},{"title":"CF77C","path":"/2024/10/23/CF77C/","content":"原题连接tag: 树形dp, 贪心, *2100 题意给定一棵大小为 的树，每个节点都有一个海狸，每次去到一个结点必须取走一个海狸，如果目的节点的值为0则无法前往，最多能够取走多少个海狸。 题解首先可以发现每个子树如果能够最优显然问题就一定是最优解，所以联想到树形 dp。设 为从 出发，在其子树中的最优解。 考虑状态转移，父节点的 dp 值显然是由子树的贡献加上到达子树所产生的贡献（因为每次都要从父节点出发最后回到父节点）。同时，由于父节点海狸数的限制，只能访问一定数量的子树，因此可以贪心的选取贡献大的子树进行访问。 如果父节点访问玩所有子树还有剩余的海狸，则可以继续和儿子中的剩余进行来回访问，将海狸数耗尽为止。 由于每次前进到相邻的边必须保证目的节点有海狸，因此除了根节点之外的所有点，考虑它们的子树的一个前提是必须能够从根节点走过来，也就是必须要花费一个海狸，因此要对非根节点的所有节点的海狸数量进行减一操作。 时间复杂度 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using ll = long long;using namespace std;int main(){ int n; cin &gt;&gt; n; vector&lt;ll&gt; a(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v), G[v].push_back(u); } int rt; cin &gt;&gt; rt; vector&lt;ll&gt; dp(n + 1); auto dfs = [&amp;](auto dfs, int u, int fa) -&gt; void { if (u != rt) a[u]--; vector&lt;int&gt; tmp; for (int v : G[u]) { if (v == fa) continue; dfs(dfs, v, u); tmp.push_back(v); } sort(tmp.begin(), tmp.end(), [&amp;](int a, int b) { return dp[a] &gt; dp[b]; }); for (int i = 0; i &lt; tmp.size() &amp;&amp; a[u]; i++) { dp[u] += dp[tmp[i]] + 2; a[u]--; } if (a[u]) { for (int v : tmp) { if (a[v]) { int t = min(a[v], a[u]); dp[u] += 2 * t; a[u] -= t; } } } }; dfs(dfs, rt, 0); cout &lt;&lt; dp[rt] &lt;&lt; endl; return 0;}"},{"title":"ABC374F","path":"/2024/10/19/ABC374F/","content":"原题连接 tag: DP 题意 个订单，分别在 天下达。 最多有 个订单可以同时发货 订单 只能在 ​ 天或之后发货 每次发货要 天后才能再次发货 每个订单的不满意度为实际发货时间 与订单下达时间之差，即 。 求所有订单的不满意度之和的最小值。 题解"},{"title":"Codeforces Round 975 (Div. 2)","path":"/2024/10/16/CF2019/","content":"A. Max Plus Size题意求奇数位之和和偶数位之和的最大值 题解略 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using ll = long long;void solve(){ int n; std::cin &gt;&gt; n; std::vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; a[i]; int mx = 0, ans = 0, cnt = 0; for (int i = 0; i &lt; n; i += 2) { mx = std::max(mx, a[i]); cnt++; } ans = std::max(ans, cnt + mx); mx = 0, cnt = 0; for (int i = 1; i &lt; n; i += 2) { mx = std::max(mx, a[i]); cnt++; } ans = std::max(mx + cnt, ans); std::cout &lt;&lt; ans &lt;&lt; \" \";}int main(){ std::ios::sync_with_stdio(false), std::cin.tie(0); int tt; std::cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} B. All Pairs Segments题意在数轴上给出 个不同的特殊点，两两之间有一条线段，问这些点中有多少个点恰好被 条线段覆盖。 题解每两个特殊点中间的点被覆盖次数即左右两边特殊点的个数之积，特殊点所被覆盖次数为左右两边特殊点的个数（不包括自己）之积再加上 。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using ll = long long;void solve(){ int n, q; std::cin &gt;&gt; n &gt;&gt; q; std::vector&lt;ll&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; std::unordered_map&lt;ll, ll&gt; mp; auto calc = [&amp;](ll x) -&gt; ll { return (x - 1) * (n - x + 1); }; for (int i = 2; i &lt;= n; i++) { mp[calc(i)] += a[i] - a[i - 1] - 1; } for (int i = 1; i &lt;= n; i++) { mp[calc(i) + 1ll * (n - i)]++; } while (q--) { ll k; std::cin &gt;&gt; k; std::cout &lt;&lt; mp[k] &lt;&lt; \" \"[q == 0]; }}int main(){ std::ios::sync_with_stdio(false), std::cin.tie(0); int tt; std::cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} C. Cards Partition题意给出 种卡牌，每种牌有 张，现在有 次购买任意一张牌的机会，求最大能够组成多大的deck。要求每个deck种牌的种类互不相同且所有deck的大小相等，并且所有的牌都要属于一个deck。 题解deck的大小肯定不大于 ，考虑从大到小枚举答案。 deck的大小一定能够整除最终卡牌的数量即 ，同时需要满足 。 还有一个需要满足的条件是 的数量 ，否则根据抽屉原理一定有一个deck中包含相同的卡牌。 时间复杂度： 。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using ll = long long;void solve(){ ll n, k; std::cin &gt;&gt; n &gt;&gt; k; std::vector&lt;ll&gt; a(n + 1); ll sum = 0; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i], sum += a[i]; sort(a.begin() + 1, a.end(), [&amp;](int x, int y) { return x &gt; y; }); ll mx = *std::max_element(a.begin() + 1, a.end()); auto check = [&amp;](int x) -&gt; bool { return (sum + k) / x &gt;= mx &amp;&amp; (x - sum % x) % x &lt;= k; }; for (int i = n; i &gt;= 1; i--) { if (check(i)) { std::cout &lt;&lt; i &lt;&lt; \" \"; return; } }}int main(){ std::ios::sync_with_stdio(false), std::cin.tie(0); int tt; std::cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} D. Speedbreaker全场mvp，通过数量不到 E 的一半。 题意一排有 个城市，从左到右编号为 。 在 1 时刻，你正好征服了一座城市，称为起始城市。 在 2,3,…,n 时刻，你可以选择一个与迄今为止征服的城市相邻的城市并征服它。 如果在每个 i 中，你在不晚于 ​ 的时间征服了城市 i ，那么你就赢了。获胜策略可能存在，也可能不存在，这也取决于起始城市。有多少个起始城市可以让你获胜？ 题解首先如果单独考虑某一个点，则能在 时刻之前到达该点的区间为 ，因此合法的点所组成的区间一定位于 。 不妨大胆猜想这个就是答案。 代入样例发现这个做法在第二个样例处（）错误，因此充分性不满足。 通过观察这一组“奇怪的”样例，发现有两个 5 它们的距离是 5，也就是位于一个长度至少为 6 的区间，无论从哪个点出发都不能在合法时间内遍历到这两个点。 实际上，对于时间 内能够到达的点来将，包含它们的区间长度一定不大于 ，也就是满足上述两个条件的点就是所有满足条件的起始点。 证明说不太清楚，参考种树。但是第二个条件如果满足的话，在满足第一个条件的点中任意找一个点作为起始点，优先向剩余时间少的点走一定不劣，从而策略一定存在。 时间复杂度：。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using ll = long long;void solve(){ int n; std::cin &gt;&gt; n; std::vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; int l = 1, r = n; std::vector&lt;std::vector&lt;int&gt;&gt; mp(n + 1); for (int i = 1; i &lt;= n; i++) { l = std::max(l, i - a[i] + 1); r = std::min(r, i + a[i] - 1); mp[a[i]].push_back(i); } int L = n, R = 1; for (int i = 1; i &lt;= n; i++) { if (mp[i].empty()) continue; L = std::min(L, mp[i][0]); R = std::max(R, mp[i].back()); if (R - L + 1 &gt; i) { std::cout &lt;&lt; 0 &lt;&lt; ' '; return; } } std::cout &lt;&lt; std::max(0, r - l + 1) &lt;&lt; ' ';}int main(){ std::ios::sync_with_stdio(false), std::cin.tie(0); int tt; std::cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} E. Tree Pruning题意给定一棵大小为 树，每次可以删除一个叶子节点以及它所连的边，问最少需要多少次这样的操作能够使树上剩下的所有叶子节点全在同一深度（根节点为1号节点）。 题解以样例为例来说明 在这棵树上，最少可以删除 5 条边使得所有叶子节点的深度相同，分别是 11，9，3，10，4。最终的叶子节点深度均为4. 可以发现我们删除的点并不都是深度大于最后深度的节点，也有小于最后深度的节点，例如4，10. 如果我们枚举最终的深度，则在原图上所有深度大于该深度的点都需要被删除，可以通过统计子树大小的方式来得到答案。 至于深度小于最终深度的叶子节点，如果我们从这些叶子节点向上考虑，还需要维护到第一个子树深度大于当前枚举深度的祖先，很难在有限时间复杂度内实现。 但是这给我们一个启发，如果处理出每个节点的中儿子能够到达的最大深度，那么如果该节点的儿子都不能达到当前枚举的深度，那么可以将当前节点的子树全部删除，这样仍然只用维护子树大小和子树所能到的最大深度，一遍dfs 即可。注意用差分将这里的贡献加到大于当前枚举深度的答案中。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long long#define PII pair&lt;int, int&gt;#define pi acos(-1.0)void solve(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; G(n + 1); for (int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v), G[v].push_back(u); } vector&lt;int&gt; sz(n + 1), dep(n + 1), up(n + 1), son_dep(n + 1); vector&lt;int&gt; ans(n + 1), b(n + 2); int mx_dep = 0; auto dfs = [&amp;](auto dfs, int u, int fa) -&gt; void { sz[u] = 1; son_dep[u] = dep[u]; mx_dep = max(dep[u], mx_dep); for (int v : G[u]) { if (v == fa) continue; dep[v] = dep[u] + 1; dfs(dfs, v, u); sz[u] += sz[v]; son_dep[u] = max(son_dep[v], son_dep[u]); } ans[dep[u]] += sz[u] - 1; b[son_dep[u] + 1]++; }; dfs(dfs, 1, 0); for (int i = 1; i &lt;= mx_dep; i++) { b[i] += b[i - 1]; } for (int i = 0; i &lt;= mx_dep; i++) ans[i] += b[i]; cout &lt;&lt; *min_element(ans.begin(), ans.begin() + mx_dep + 1) &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"},{"title":"All-Ukrainian School Olympiad in Informatics A. Gift","path":"/2024/10/12/CF76A/","content":"原题链接 tag: 最小生成树，贪心，*2200 题意给定一个 个点， 条边的图，同时给定两个正整数 ，每条边有 两个权重，求图的一棵生成树 ，使得 ​ 最小，求出这个最小值。 题解考虑暴力的做法，由于是双变量最优化问题，考虑枚举某一个变量对另外一个变量进行优化。在本题中可以枚举最大的 值，用所有小于 的边建图，然后在这张图上以最小化 跑 最小生成树。这样做的时间复杂度为 。 考虑如何优化，可以发现以下性质： 如果一个边在上一次枚举 的时候没有被选中，那么在后续的枚举（假设是从小到大枚举 值）中一定不会被选中。 因为前面已经可以选择一些拥有更小 的边来连接使相同的一些点连通，而且可选的边会越来越多，肯定没有必要选当前的边，直接删掉即可，这样可以保证每一轮所剩下的边只有最多 条。时间复杂度降为 ，大约 。 如果要继续优化，由于每次枚举 值时相对于上一轮只会多加入一条边，不用每次都重新排序然后跑 ，只需要在上一次得到的边集中按照插入排序的方式插入这条边，然后再跑 ，并将这一轮得到的边集传递给下一轮。 时间复杂度 。 代码In queue中…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long long#define PII pair&lt;int, int&gt;#define pi acos(-1.0)constexpr ll inf = 0x7fffffffffffffffll;struct edge { int u, v; ll g, s; bool operator==(const edge&amp; a) const { return u == a.u &amp;&amp; v == a.v &amp;&amp; g == a.g &amp;&amp; s == a.s; } bool operator&lt;(const edge&amp; a) const { return s &lt; a.s; }};struct DSU { std::vector&lt;int&gt; p; DSU(int n) { p.resize(n + 1); std::iota(p.begin(), p.end(), 0); } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } bool same(int a, int b) { return find(a) == find(b); } void merge(int a, int b) { p[find(a)] = find(b); }};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, m; ll G, S; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; G &gt;&gt; S; vector&lt;edge&gt; e; for (int i = 1; i &lt;= m; i++) { int u, v; ll g, s; cin &gt;&gt; u &gt;&gt; v &gt;&gt; g &gt;&gt; s; if (u == v) continue; e.push_back({u, v, g, s}); } sort(e.begin(), e.end(), [](const edge&amp; a, const edge&amp; b) { return a.g &lt; b.g; }); vector&lt;edge&gt; cur; vector&lt;edge&gt; past; ll ans = inf; for (int i = 0; i &lt; e.size(); i++) { cur.assign(past.begin(), past.end()); cur.push_back(e[i]); for (int j = cur.size() - 1; j &gt;= 1; j--) { if (cur[j].s &lt; cur[j - 1].s) swap(cur[j], cur[j - 1]); } past.clear(); int cnt = 0; DSU T(n); ll max_g = 0, max_s = 0; for (int j = 0; j &lt; cur.size(); j++) { auto [u, v, g, s] = cur[j]; if (!T.same(u, v)) { T.merge(u, v); past.push_back(cur[j]); max_g = max(max_g, g), max_s = max(max_s, s); cnt++; if (cnt == n - 1) break; } } if (cnt == n - 1) ans = min(ans, G * max_g + S * max_s); } ans = ans == inf ? -1 : ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;}"},{"title":"Codeforces Round 976 (Div. 2) and Divide By Zero 9.0","path":"/2024/10/11/CF2020/","content":"链接 VP赛时 ABCD，补题EF 分数：800 - 1200 - 1400 - 1800 - 2000 - 2900 A、B、C没什么好说的。 D题赛时卡了，没想到 这个条件怎么用，技巧 +1 E题回顾了一下一个较为经典的概率dp。 F题正好复习一下前段时间刚学会的 min_25 筛（确实好用，也顺便整理了一下 min_25 的板子。 A. Find Minimum Operations题意给定两个整数 ，每次操作可以从 上减去 的非负整数幂，求将 变成 的最小操作次数。 题解如果 ，显然需要 次。 否则预处理出所有小于 的 的幂，每次在二分找最大的不超过当前 的幂减去。如果最后 ，直接将答案加上剩下的 即可。 时间复杂度： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;ll&gt; a; ll t = k; a.push_back(1); if (k != 1) { while (t &lt;= n) { a.push_back(t); t *= k; } } int cnt = 0; while (n) { int l = 0, r = a.size() - 1; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (a[mid] &lt;= n) l = mid; else r = mid - 1; } n -= a[l]; cnt++; if (a[l] == 1) { cnt += n; break; } } cout &lt;&lt; cnt &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} B. Brightness Begins题意有 个灯泡，编号为 ，最开始所有灯都是亮的，然后进行如下操作： 对于 ，反转所有 灯泡。 执行完所有操作后，将会有一些灯泡是亮的。 找出最小的 使得执行完操作后恰好有 ​ 个灯泡是亮的。 题解每个灯泡只会被自己的因数操作翻转，如果一个数的因数是偶数，则操作完后仍然是亮的。因数为奇数当且仅当这个数是完全平方数。 因为原题可以变成找出最小的 使得 中恰好有 个完全平方数。 时间复杂度： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll k; cin &gt;&gt; k; auto check = [&amp;](ll x) { ll l = 1, r = 2e9; while (l &lt; r) { ll mid = (l + r + 1) &gt;&gt; 1; if (mid * mid &lt;= x) l = mid; else r = mid - 1; } return l &lt;= x - k; }; ll l = 1, r = 4e18; while (l &lt; r) { ll mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} C. Bitwise Balancing题意给定三个非负整数 ，求方程的解，无解打印 -1。 题解考虑拆位，如果 上某一位是1，则 上这一位必为1， 上这一位必为 0，因为不可能出现 上这一位为0， 上这一位为 1的情况。 如果 上某一位是0，则两者在这一位上必然相等。 分情况讨论即可。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll b, c, d; cin &gt;&gt; b &gt;&gt; c &gt;&gt; d; ll ans = 0; for (int i = 0; i &lt;= 62; i++) { if ((d &gt;&gt; i) &amp; 1) { if (!((b &gt;&gt; i) &amp; 1)) { if ((c &gt;&gt; i) &amp; 1) { cout &lt;&lt; -1 &lt;&lt; endl; return; } else ans += (1ll &lt;&lt; i); } } else { if ((b &gt;&gt; i) &amp; 1) { if (!((c &gt;&gt; i) &amp; 1)) { cout &lt;&lt; -1 &lt;&lt; endl; return; } else { ans += (1ll &lt;&lt; i); } } } } // assert((ans | b) - (ans &amp; c) == d); cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} D. Connect the Dots题意有 这些点，起初都是孤立点，接下来 次操作，每次操作选择三个整数 ，然后连接 这些点，使其连通。 执行完所有操作后，问这些点形成了多少个连通块。 题解发现 很小，最大只有10，考虑维护每个点后面十个点是否与它连通，连通可以直接用并查集维护。 由于每次操作涉及多个点，为了降低时间复杂度，每次将从 开始打标记，当计算完 和他后面十个点的边之后，将 的标记传递给 ，直到序列的结尾点。 时间复杂度： 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;struct DSU { std::vector&lt;int&gt; p; DSU(int n) { p.resize(n + 1); std::iota(p.begin(), p.end(), 0); } int find(int x) { if (p[x] != x) { p[x] = find(p[x]); } return p[x]; } bool same(int a, int b) { return find(a) == find(b); } void merge(int a, int b) { p[find(a)] = find(b); }};void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; DSU T(n); int a, d, k; vector&lt;vector&lt;int&gt;&gt; tag(n + 1, vector&lt;int&gt;(11)); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a &gt;&gt; d &gt;&gt; k; tag[a][d]++; tag[a + k * d][d]--; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= 10; j++) { if (tag[i][j] &gt; 0) { T.merge(i, i + j); tag[i + j][j] += tag[i][j]; } } } int ans = 0; unordered_set&lt;int&gt; st; for (int i = 1; i &lt;= n; i++) st.insert(T.find(i)); cout &lt;&lt; st.size() &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} E. Expected Power题意给定一个数组 和概率数组 ，每个 有 的概率被插入到可重集 中。 求 。 其中 表示 中所有元素的异或和。 题解观察到 范围很小，于是 的范围也一定是 ，于是 可以表示为而 可以用经典的概率 dp 求解： 设 为考虑前 个数，选择一些数使得异或和为 的概率，于是有转移方程：直接计算即可，注意到 只会从 转移而来，可以滚动掉一维。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longconstexpr ll mod = 1e9 + 7;constexpr ll mu = 285700002;void solve(){ int n; cin &gt;&gt; n; vector&lt;ll&gt; a(n + 1), p(n + 1); ll B = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; B = max(B, __lg(a[i])); } B++; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i], p[i] = (p[i] * mu) % mod; vector&lt;ll&gt; dp(1024); dp[0] = 1; for (int i = 1; i &lt;= n; i++) { vector&lt;ll&gt; nxt(1024); for (int j = 0; j &lt; 1024; j++) { nxt[j] = (nxt[j] + (dp[j] * (1 - p[i] + mod) % mod) % mod) % mod; nxt[j ^ a[i]] = (nxt[j ^ a[i]] + dp[j] * p[i] % mod) % mod; } for (int j = 0; j &lt; 1024; j++) dp[j] = nxt[j]; } ll ans = 0; for (int i = 1; i &lt; (1 &lt;&lt; B); i++) { ans = (ans + ((1ll * i * i) % mod) * dp[i] % mod) % mod; } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} F. Count Leavestag ：min_25筛 题意原题题意可化为： 求 。 其中 ，的因数个数 。 题解首先不难发现当给定 时，如果 则 ，也就是说 满足积性函数。 考虑 中 为质数时， 的值相当于求有多少条长度为 的路径使得 中始终有 ， 为素数时，这样的路径只会有 条。 考虑 其中 为素数，则这样的路径有 种，而 是多项式形式，因此有 ​ ，考虑用 min_25 筛求前缀和。 时间复杂度： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longconstexpr ll mod = 1e9 + 7;constexpr int N = 1e6 + 10;ll qpow(ll aa, int bb){ ll res = 1; while (bb) { if (bb &amp; 1) res = (res * aa) % mod; aa = (aa * aa) % mod; bb &gt;&gt;= 1; } return res;}struct Combnum { vector&lt;ll&gt; fac, ifac; int n; void init(int _n) { this-&gt;n = _n; fac.resize(n + 1, 0), ifac.resize(n + 1, 0); fac[0] = 1; for (int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; ifac[n] = qpow(fac[n], mod - 2); for (int i = n - 1; i &gt;= 0; i--) { ifac[i] = ifac[i + 1] * (i + 1) % mod; } } ll C(ll i, ll j) { if (i &lt; j) return 0; return (fac[i] * ifac[j] % mod) * ifac[i - j] % mod; }} c;void solve(){ ll n, K, d, cp, cnt = 0, tot = 0; cin &gt;&gt; n &gt;&gt; K &gt;&gt; d; vector&lt;ll&gt; primes, sum, w, id1, id2, g; vector&lt;bool&gt; st; cp = c.C(K + d, d); ll sq = sqrt(n); primes.assign(2 * sq + 7, 0); st.assign(2 * sq + 7, false); g.assign(2 * sq + 7, 0); w.assign(2 * sq + 7, 0); id1.assign(2 * sq + 7, 0); id2.assign(2 * sq + 7, 0); sum.assign(2 * sq + 7, 0); auto sieve = [&amp;](int n) -&gt; void { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[++cnt] = i, sum[cnt] = (sum[cnt - 1] + cp) % mod; for (int j = 1; j &lt;= cnt &amp;&amp; i * primes[j] &lt;= n; j++) { st[i * primes[j]] = true; if (i % primes[j] == 0) break; } } }; sieve(sq); for (ll l = 1, r; l &lt;= n; l = r + 1) { r = min(n, n / (n / l)); w[++tot] = n / l; g[tot] = cp * (w[tot] % mod - 1) % mod; if (w[tot] &lt;= sq) id1[w[tot]] = tot; else id2[n / w[tot]] = tot; } for (int j = 1; j &lt;= cnt; j++) { for (int i = 1; i &lt;= tot &amp;&amp; primes[j] * primes[j] &lt;= w[i]; i++) { ll tmp = w[i] / primes[j]; int p = tmp &lt;= sq ? id1[tmp] : id2[n / tmp]; g[i] = (g[i] - (g[p] - sum[j - 1] + mod) % mod + mod) % mod; } } auto S = [&amp;](auto S, ll i, ll j) -&gt; ll { if (primes[j] &gt;= i) return 0; ll p = i &lt;= sq ? id1[i] : id2[n / i]; ll ans = (g[p] - sum[j] + mod) % mod; for (int k = j + 1; k &lt;= cnt &amp;&amp; primes[k] * primes[k] &lt;= i; k++) { ll pe = primes[k]; for (int e = 1; pe &lt;= i; e++, pe = pe * primes[k]) { ans = (ans + c.C(d + e * K, d) * ((S(S, i / pe, k) + (e &gt; 1)) % mod) % mod) % mod; } } return ans; }; cout &lt;&lt; (S(S, n, 0) + 1) % mod &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; c.init(N * 10); while (tt--) { solve(); } return 0;}"},{"title":"Educational Codeforces Round 169 (Rated for Div. 2) F. Make a Palindrome","path":"/2024/10/10/CF2004F/","content":"原题链接 tags: 思维，前缀和，*2600 题意给你一个长度为 序列 ，求 。 其中 将返回将数组 变为回文数组的最小操作次数，有以下两种操作： 选择数组中两个相邻的数 ，删除它们并用元素 插入。 选择数组中一个数 ，用两个正整数 替换它。 题解谁能想到一道 *2600 的题核心代码只有20行…… 显然存在一个上界 ，因为可以一直选两个数合并直到剩下一个数。 要得到这个上界还有一种方法是，每次选择两头中较大的那个数进行拆分成较小的数和另外一个数，这样做每次能使得两头变成一样，然后子问题的规模就减少了两个数字，同时多出来一个数，总体上相当于少了一个数，也是需要最多 次就能变成回文。 考虑如何减小操作次数。显然，如果两端的数已经相等，肯定不用操作。 但是有可能会出现这种情况 ，按照上面的处理办法最多 4 次，但是会发现前缀 和后缀 的和相等，于是可以用两次操作变成 ，总的操作次数来到 2 次，接下来考虑这样做为什么会减少操作次数。 设前缀的长度为 ，区间和相同的后缀长度为 ，按照我们原来的操作，在这两段数组上所需要的操作次数就是 ，但现在我们只需要将两段数组分别合并成一个数就能归约为相同的子问题，需要的操作次数为 。也就是说，只要有 的区间和相等，则对于 来说，答案就可以减少 1。 考虑贡献法，用桶来记录所有出现的区间和，对于每一个新加入的区间，若区间和为 ，则对答案的贡献为桶中记录的 的个数，因为其中任意一个与它组合都代表着一个区间的答案能够减 1。 有一种情况值得一提，假如是两个有着相同区间和的区间有重叠怎么办。 例如 和 ，其中 ，显然此时能够得到 和 的区间和也相等。因此 上的答案会被减少两次。 事实也是如此，我们可以选择 和 分别合并成一个数，然后在将剩余的 中的数合并成一个数，这样做相对于 ​ 的答案来说的确减少了 2 次操作。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i]; int ans = 0; for (int l = 1; l &lt;= n; l++) { for (int r = l; r &lt;= n; r++) { ans += r - l; } } unordered_map&lt;int, int&gt; mp; for (int len = 1; len &lt;= n; len++) { for (int l = 1; l + len - 1 &lt;= n; l++) { int r = l + len - 1; int t = sum[r] - sum[l - 1]; ans -= mp[t]; mp[t]++; } } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"},{"title":"Pinely Round 4 (Div. 1 + Div. 2) F. Triangle Formation","path":"/2024/10/09/CF1991F/","content":"原题链接 tags: 思维，数学，*2200 题意给你一个长度为 的序列 ，进行 次询问，每次询问给出 ，询问区间 中能否选出 个数组成两个非退化的三角形。 非退化三角形：边长分别为 ，则有： 题解一开始以为会是一道数据结构大题…… 但是很容易发现，如果一个区间中不包含两个退化的三角形，则一定有任意三个数都不满足上面三个条件，更具体的，任意选三个数，最小的两个数相加一定小于等于最大的那个数。 那么将区间中所有的数按照递增排序，则有 ，这使我们联系到斐波那契数列，由于斐波那契数列增长速度相当快，打表发现满足小于 ​ 的只有前 44 项。 123456vector&lt;long long&gt; a = {1, 1};while (a.back() &lt;= 1e9) { a.push_back(a[a.size() - 1] + a[a.size() - 2]);}cout &lt;&lt; a.size() &lt;&lt; endl; // 45cout &lt;&lt; a.back() &lt;&lt; endl; // 1134903170 因此当区间长度大于 44 是就一定存在一个非退化的三角形，如果再往区间中扔 3 个数，则一定存在两个非退化的三角形，因此只要区间长度大于47，则一定存在两个非退化的三角形，下面考虑计算长度小于等于 47 的区间。 首先还是先将区间中所有数拿出来排序（因为现在个数很少，直接暴力验证）。有两个性质需要说明： 对于已经能够形成三角形的 3 个数，在保证仍然是最小的条件下将最小的边拉长将不会影响合法性。 对于已经能够形成三角形的 3 个数，在保证仍然是最大的条件下将最大的边拉短将不会影响合法性。 有了这两条性质，我们能够得到，在排好序的序列中，选择相邻的三个合法的一定更优，若不存在三个相邻的数能够组成非退化三角形则整个序列中都不会存在。 因此，我们只需要扫一遍排好序的序列，判断是否有不相交的两组相邻三个数能够组成非退化三角形，如果存在打印“YES”。 上面只考虑了两组数不相交的情况，但是有可能存在两组数相交的特例。例如： ，如果选择两组相邻的，即 和 ，前面第一组就不合法，如果按照 和 ​ 进行划分就存在合法解。因此我们还需要扫一遍相邻 6 个数判断是否存在两组合法解。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int d[9][6] = { {1, 2, 4, 3, 5, 6}, {1, 2, 5, 3, 4, 6}, {1, 2, 6, 3, 4, 5}, {1, 3, 4, 2, 5, 6}, {1, 3, 5, 2, 4, 6}, {1, 3, 6, 2, 4, 5}, {1, 4, 5, 2, 3, 6}, {1, 4, 6, 2, 3, 5}, {1, 5, 6, 2, 3, 4}};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (q--) { int l, r; cin &gt;&gt; l &gt;&gt; r; if (r - l + 1 &gt;= 48) { cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } vector&lt;int&gt; nums; for (int i = l; i &lt;= r; i++) { nums.push_back(a[i]); } sort(nums.begin(), nums.end()); auto check = [&amp;](int a, int b, int c) { return a &lt; (b + c) &amp;&amp; b &lt; (a + c) &amp;&amp; c &lt; (a + b); }; vector&lt;int&gt; ok; bool have = false; for (int i = 0; i &lt; nums.size() - 2; i++) { if (check(nums[i], nums[i + 1], nums[i + 2])) { ok.push_back(i); if (ok.back() &gt; ok[0] + 2) { have = true; break; } } } if (ok.empty()) { // 不存在合法三角形 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } if (have) { // 存在不相交的两组数 cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } for (int i = 0; i &lt; nums.size() - 5; i++) { for (int j = 0; j &lt; 9; j++) { if (check(nums[i + d[j][0] - 1], nums[i + d[j][1] - 1], nums[i + d[j][2] - 1]) &amp;&amp; check(nums[i + d[j][3] - 1], nums[i + d[j][4] - 1], nums[i + d[j][5] - 1])) { have = true; break; } } if (have) break; } if (have) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } } return 0;}"},{"title":"Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley","path":"/2024/10/08/CF1994F/","content":"原题连接 tag: 图论，欧拉回路，*2500 题意给出一个连通无向图， 个点 条边，边分成必选边和非必选边，可以存在重边和自环，要求选出一条路径包含所有的必选边，并且选出的路径上所有边（必选边和非必选边）只经过一次，并且能够回到起点。 题解由于路径上每条边只经过一次，并且要形成一个环，不难想到最后如果答案存在一定构成一条欧拉回路。回想欧拉回路的性质，每个点的度数都是偶数，且连通，因此题目的意思是：是否可以删掉原图中一些非必选边，使得剩下的图包含一个欧拉回路，也就是所有点的度数都是偶数。 有了这个想法后，发现代码并没有很容易实现。如果一开始用所有的边建图，然后考虑删掉一些边使得所有点的度数均为偶数，这样的做法很难找到删掉哪些边能够满足条件。 考虑反过来，如果我们从必选边开始，逐渐加入非必选边，那么最后的图一定是一个欧拉回路。因此我们可以从必选边开始，逐渐加入非必选边，如果最后的图是一个欧拉回路，那么就符合题意。 一个比较容易实现的方法是考虑非必选边所构成的子图，用 dfs 进行遍历，在 dfs 遍历的过程中，如果发现一个点的度数为奇数，则删掉和它父亲相连的一条边，使得这个点的度数变成偶数，最后如果根节点的度数是奇数，说明不能满足所有点的度数都是偶数的条件。 最后在所有选出的边中跑一边求欧拉回路即可。 时间复杂度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; d(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); vector&lt;int&gt; u(m + 1), v(m + 1), w(m + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; if (w[i]) d[u[i]]++, d[v[i]]++; G[u[i]].push_back(i), G[v[i]].push_back(i); } vector&lt;bool&gt; vis(n + 1); auto dfs = [&amp;](auto dfs, int x) -&gt; void { vis[x] = true; for (int i : G[x]) { int y = u[i] ^ v[i] ^ x; if (vis[y] || w[i] == 1) continue; dfs(dfs, y); if (d[y] &amp; 1) { d[x]--, d[y]--; w[i] = 1; // 选 } } }; for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(dfs, i); if (d[i] &amp; 1) { cout &lt;&lt; \"NO \"; return; } } cout &lt;&lt; \"YES \"; vector&lt;int&gt; ans; // 这种找欧拉回路T了 // auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { // for (int i : G[x]) { // if (w[i] == 0) continue; // int y = u[i] ^ v[i] ^ x; // w[i] = 0; // dfs2(dfs2, y); // } // ans.push_back(x); // }; auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { while (G[x].size()) { int i = G[x].back(); G[x].pop_back(); if (w[i] == 0) continue; int y = u[i] ^ v[i] ^ x; w[i] = 0; dfs2(dfs2, y); } ans.push_back(x); }; dfs2(dfs2, 1); cout &lt;&lt; ans.size() - 1 &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i] &lt;&lt; \" \"[i == ans.size() - 1]; }}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"},{"title":"最优化算法","path":"/notes/最优化算法.html","content":"一维无约束优化主要讨论一维（单峰函数）的最小化问题算法单峰函数：如果一维函数在定义域区间 上有*唯一局部极小点 $x^{}，则f(x)称为区间[a_0, b_0]$ 上的 单峰函数（unimodel function）。 性质：在 上任取两点 且 ，则极小值 一定位于 之间 ，则极小值 一定位于 ​ 之间 等比例压缩法每次在当前区间按等比例取两个点 每次迭代后区间变成原来的 倍，故 次迭代后总压缩比为 ，其中每次压缩要取两个点重新计算函数值并比较，所以调用 次数为 。 黄金分割法在等比例压缩法的基础上将压缩比设置为 ，好处是每一次产生的新区间中总包含了上一次计算的一个点，使得下一次运算时该店可以重复使用。 总压缩比为 ，调用次数为 （第一次还是要算两个点，其余每次只多算一个点）。 斐波那契法前面两种方法是 要求达到目标压缩比，能否 给定迭代次数 ，但允许 的值动态改变，使得 次迭代后的压缩比最小，并且仍然每次只增加对一个点的目标函数进行计算。 即满足 转化成求：满足以下序列的解即为改最优化问题的最优解：（证明过程P78）注意：在第 次迭代时 ，此时两个点重叠，需要加上一个扰动量 ，即 ，因此，对于极小点所在的区间的压缩比可能是： 或 总压缩比为 在 趋于无穷时，黄金分割法实际上和斐波那契法有着相同的压缩比 二分法需要目标函数 连续可微， Step 1 确定初始区间的中点 Step 2 计算函数 在中点的导数 。如果 ，说明极小点在 左侧，压缩下一次的搜索区间为 。如果 ,说明较小点位于 右侧，下一次迭代玉缩区间为 。最后，如果 , 说 明 是极小点。 Step 3 按照第2步迭代，根据 的大小来压缩区间，直到区间大小小于预期要求或者 (由于数值误差，后者一般不会出现，所以停机条件会要求区间大小在某一约束内) 方法 压缩比 调用 次数 等比例压缩法 黄金分割法 斐波那契法 二分法 \\ 确定初始搜索范围bracket_ minimum算法 牛顿搜索方法若 在 二阶连续可微，则可以利用作为 在 附近的近似 牛顿法利用 的极小点作为 ，即下次迭代点，即 牛顿法求解方程牛顿法迭代过程中并不需要计算 ，却能找到 的点。因此，令 ，牛顿法也能求解方程 ，迭代方程为有可能会因为 不够小失效 割线法利用不同点处的一阶导数近似二阶导数由于每次迭代使用了两个点的信息，初始点需要有两个 和 。 二次拟合搜索不计算一阶导数的情况下，求解上述一维最优化问题。 令：Missing \\left or extra \\right X=\\begin{bmatrix}\\left(x^k\\right)^2&amp;x^k&amp;1\\\\left(x^{k-1}\\right)^2&amp;x^{k-1}&amp;1\\\\left(x^{k-2}\\right)^2&amp;x^{k-2}&amp;1\\end{bmatrix},y=\\begin{bmatrix}f(x^k)\\f(x^{k-1})\\f(x^{k-2})\\end{bmatrix},\\text{则}A\\begin{bmatrix}a\\b\\c\\end{bmatrix}=y 由 克 拉 默 法 则 , b, 其 中 为 用 y取 代 的 第 1 和第 2 列后的矩阵。 实际上，我们并不需要计算参数。考虑二次函数的最小值为 ，我们只需要计算 多维函数多维实值函数定义域为 ，值域为 或者 ​ 的函数。 函数水平集即函数的“等高线”。 二次型（Quadratic form）指二次齐次多项式。 二次型函数最高阶为二次型的实函数，即 其中 是一个 的实数矩阵，即 。 观察：给出 ，其中 ，我们可以将 转化为一个对称矩阵对任意 ​ 有上述观察说明我们总可将二次型函数中的矩阵 变成对称阵。 将二次型函数写成矩阵的形式，例如将 写成 的形式，要求 是对称矩阵。 判断正定矩阵正定矩阵定义：给出对称矩阵 ，如果对于任意一个非零向量 满足：则是一个正定矩阵。如果 ，则 是一个半正定矩阵。相应的，如果对于所有的 ， ​ 是负定矩阵(半负定矩阵) 性质2：对称矩阵 是正定（半正定）矩阵当且仅当所有的特征值都是正的（非负的）。 性质1：对称矩阵 是正定的当且仅当 的所有顺序主子式是正的。 注意：顺序主子式非负是矩阵半正定的必要条件，非充分条件。即，矩阵半正定 =&gt; 顺序主子式非负，但顺序主子式非负 矩阵半正定。 范数函数 1 - 范数 (L1):$|x|1=\\sum{i=1}^n|x_i|$ ——曼哈顿距离 欧式范数(L2——欧式距离 - 范数： 无穷范数：$|x|\\infty=\\max{1\\leq i\\leq n}|x_i|$ 梯度梯度(Gradient)：如果函数 一阶可微,那么函数称为 在点 处的梯度。 常见的多维函数梯度 常数向量，则 ，则 ，则 若是阶对称矩阵， ，则 若是阶对称矩阵， ，则 ​ 雅可比矩阵雅可比矩阵（Jacobi matrix）：如果，即且​可微，那么称为 在 处的导数，也称为 在 的雅可比矩阵。 当 时， 。 多维函数求导的链式法则给定复合函数(设 ，其 中 每 个 都是关于 的函数，即 ，有 其中 表示 关 于 的导数（雅可比矩阵）。 可行方向和方向导数黑塞（Hessian）矩阵黑塞矩阵(Hessian)如果​是二阶可微的,矩阵称为 在点 处的黑塞矩阵，其中 表示 首先对 然后再对 求导。注意:教材中常记为 ，或 。 对于二阶导数连续的函数，其 Hessian 阵为对称矩阵。 凸集、凸函数、凸优化暂时略 无约束优化无约束优化： 为定义在 上的可微函数。无约束优化要求求解 线性回归试图学得一个线性模型，通 过因素、属性或者说特征的线性组合，来尽可能准确地预测实 际输出值，即寻求线性函数基于均方误差最小化来进行模型求解的方法也被称为**“最小二乘法”(least square method)**。 带正则项的线性回归 范数正则项：如果想要得到一个稀疏的解，就是解中非零分量的个数尽可能少，可借助或者范数。其中被称为正则项，上述模型也被称为LASSO (Least Absolute Shrinkage and Selection Operator) 岭 回 归 : 为 了 平 衡 模 型 的 拟 合 性 质 和 解 的 光 滑 性 , 还 可 以 用 正则项通过设置合适的 值，上述目标函数可以变成严格凸函数，使得解性质得到改善。 无约束优化最优性条件一阶必要条件（FONC）一阶必要条件：设 一阶连续可微。如果 是局部极小点，则利用一阶泰勒展开式证明即可。 注意： 驻点（平稳点）是一阶导数为 ​ 的点。 极大值、极小值、鞍点都可能是平稳点。 二阶必要条件（SONC）二阶必要条件：设 二阶连续可微。如果 是局部极小点，则且是半正定证明：如果非半正定，则存在 ，使得 ，然后用二阶泰勒展开即可。 二阶充分条件（SOSC）设 二阶连续可微。如果点 $\\boldsymbol{x}^\\in \\mathbb{R}^n满足 abla f(\\boldsymbol{x}^)=0\\text{且} abla^2f(\\boldsymbol{x}^*)正定，则是一个严格极小点证明：根据泰勒级数，领域内任意一个值都要比它更大，即$注意：SOSC不是必要条件。 凸函数最优性条件凸优化能保证驻点为局部极小点，也就是全局极小点。 无 约 束 凸 优 化 : 设 凸 函 数 在上连续可微，则存在 $x^\\in\\mathbb{R}^n使得 abla f(x^)=0\\Leftrightarrow x^*是\\min f(x)$全局最优解。 证明： 根据凸函数性质，对于任意点,有因此。 是全局最优解 是全局最优解，则必然也是局部最优解，由FONC可得 ​。 下降法难以求解 获得平稳点时，采用更常见的无约束求解方法：下降算法 步骤： 首 先 确 定 目 标 函 数 的 极 小 点 的 一 个 初 始 估 计 : ​。 然后按照一定规则产生一个下降方向 。 再沿方向 ，求得下一个迭代点 即在射线 上确定一个新点： ，使得 ，其中 称为步长因子。 若满足停机条件则输出 ，否则 ，转到第二步 注意：机器学习中 也常常被称为学习率。 下降方向下降方向：设函数 ，点 和某个向量 ，如果存在 ，使得 ，则 为下降方向。由泰勒展开式，即存在 使得因此 是 在 的下降方向 满足 ​ 。 负梯度 ​ 就是一个的下降方向。 确定步长因子 固定步长 衰减步长因子： ，其中 精确/近似线搜索： ，则 。 精确线搜索性质：由于 ，对 求导得：换句话说，在精确线搜索中， 在 处的梯度和 方向正交。 近似线搜索充分下降条件 (Amijo条件) ：（待学习理解）选择常数 （通常 ），满足回溯线搜索： 曲率条件停机条件 或 一阶方法共轭梯度法共轭定义：设且, 对于方向 ，如果对于所有的 都有 ，则称它们是关于 ​ 共轭的。 二次型下的共轭方向法针对 ， 的闭式解： 令 ，则再由 FONC 得证明：由于方向 线性无关，存在 满足：…… 找出一组 ​ 共轭的向量 共轭梯度法：利用上一次搜索方向和目标函数在当前迭代点的梯度向量之间的线性组合构造一个新方向，即 ，使其与前面已经产生搜索方向组成 共轭方向。 初始方向： 时： 那么 ，其中 时 : 设 第 次 的 方 向 为 , 第 次 的 梯 度 是 ，设 为了使 和 关于 共 轭 , 应 有因此对于 ，共轭梯度法的搜索方向 是关于的共轭方向。"}]